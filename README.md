# Concurrency-Driven Reservation System
"동시성 사고를 재현하고, 설계로 해결한다."

1. 프로젝트 목적
실무 환경에서 예약 시스템은 다음과 같은 문제를 가진다.
- 동시에 여러 사용자가 같은 좌석을 예약
- 트랜잭션이 있어도 데이터 적합성이 깨질 수 있음

이 프로젝트는 단순 CRUD가 아니라, 동시성 이슈를 의도적으로 재현하고, 설계적 해결을 비교 분석하는 것을 목표로 한다.

## 1단계 - 기본 트랜잭션 (동시성 붕괴)
#### 실험 조건
- 좌석 수: 1
- 동시 요청: 100개
- 단순 트랜잭션 환경

#### 결과
- 좌석이 음수로 감소
- Lost Update 발생
- 정합성 붕괴 확인

#### 원인 분석
- 기본 트랜잭션은 원자성은 보장하지만 동시에 동일 row를 읽는 것을 막지 못함
- READ_COMMITTED 환경에서 충돌 발생

## 2단계 - 비관적 락 적용
#### 적용 방식
Repository에 PESSIMISTIC_WRITE 적용
```
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("select c from Concert c where c.id = :id")
Optional<Concert> findByIdForUpdate(@Param("id") Long id);
```
=> Service에서 해당 메서드 사용

#### 실혐 결과
- 예약 성공: 1건
- 나머지 요청: "좌석 부족"
- 좌석 음수 발생 없음
- 정합성 완전 유지

#### 성능 관찰
- 동시 요청이 순차 처리됨
- 인위적 지연(1000ms) 추가 시 대기 현상 명확히 확인
- 처리량 감소 확인

## 3단계 - 낙관적 락 적용
- @Version 기반 충돌 감지
- ObjectOptimisticLockingFailureException 발생
- 재시도 전략 적용
- 재시도 횟수 초과 시 실패 처리
- H2 환경 특성상 충돌 재현 한계 존재

=> 실제 MySQL/PostgreSQL 환경에서는 충돌 빈도가 증가하며, 인메모리 DB에서는 충돌 재현이 제한적임을 확인함.
## ⚖ 트레이드오프 분석
| 항목     | 기본 트랜잭션 | 비관적 락  |
| ------ | ------- | ------ |
| 정합성    | ❌ 깨짐    | ⭕ 유지   |
| 처리량    | 높음      | 낮음     |
| 충돌 처리  | 없음      | 선점적 차단 |
| 병목 가능성 | 낮음      | 높음     |

## 다음 단계 계획
- 보상 트랜잭션 설계

## 핵심 
- 트랜잭션 != 동시성 완전 해결
- 동시성은 설계의 문제
- 도메인에 불변 규칙이 필요
